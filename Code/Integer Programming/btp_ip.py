# -*- coding: utf-8 -*-
"""BTP_IP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dzcHxpxdd-fAHrIy1sPRldiMHqJZzBo0

# **Integer Programming Method for Edge Data Distribution (EDD) problem**
"""

# Install required libraries of python-pulp.
!pip install pulp

# Pick the test case to evaluate EDD.
print("Enter 1 for small input testcase OR 2 for large input test case")
n = int(input())
fileName = ""
if (n == 1):
  fileName = "/content/input.txt"
elif (n == 2):
  fileName = "/content/large_input.txt"

inputFile = open(fileName, "r")
V, E, R = [int(x) for x in inputFile.readline().split()]          # V, E, R - vertex, edges and destination edge servers.
dLimit, gamma = [int(x) for x in inputFile.readline().split()]
G = {(i, j): 0 for i in range(V+1) for j in range(V+1)}
dest_edge_servers = []
edges = []

for i in range(E):
  (u, v) = [int(x) for x in inputFile.readline().split()]
  edges.append((u, v))

for i in range(R):
  v = [int(x) for x in inputFile.readline().split()]
  dest_edge_servers.append(v[0])

inputFile.close()

Gamma = {(i, j): 1 for i in range(V+1) for j in range(V+1)}       # To keep track of the cost with any edge.
DLimit = 1 + dLimit

for (x, y) in edges:
  G[x, y] = 1
  G[y, x] = 1

for x in range(1, V+1):
  G[0, x] = 1
  Gamma[0, x] = gamma

# Import pulp and create a minimize optimization problem.
import pulp as plp
opt_model = plp.LpProblem("IP_Problem", plp.LpMinimize)

# H[v] to denote if edge server 'v' is visited or not in EDD.
H = {(i): plp.LpVariable(cat=plp.LpBinary, name="H_{0}".format(i)) for i in range(V+1)}

# T[u, v] to denote if edge (u, v) is used or not.
T = {(i, j): plp.LpVariable(cat=plp.LpBinary, name="T_{0}_{1}".format(i, j)) for i in range(V+1) for j in range(V+1)}

NT = {(i, j): plp.LpVariable(cat=plp.LpInteger, name="NT_{0}_{1}".format(i, j)) for i in range(V+1) for j in range(V+1)}

PT = {(i, j): plp.LpVariable(cat=plp.LpInteger, name="PT_{0}_{1}".format(i, j)) for i in range(V+1) for j in range(V+1)}

# D[v] to denote the depth of edge server 'v' in EDD IP.
D = {(i): plp.LpVariable(cat=plp.LpInteger, name="D_{0}".format(i)) for i in range(V+1)}

if (DLimit == 1):           # Base condition when D_limit = 1.
  print("Optimal Solution")
  print("Optimal Cost = " + str(R*gamma))
else:
  # Optimization problem statement.
  opt_model += plp.lpSum(Gamma[i, j] * T[i, j] for i in range(V+1) for j in range(V+1))   

  # Constraint H[j] == 1 for j in destination edge servers.
  for j in dest_edge_servers:
      opt_model += H[j] == 1

  # Constraint on Depth D[j].
  opt_model += D[0] == 0
  for j in range(1, V+1):
      opt_model += D[j] <= DLimit
      opt_model += D[j] >= D[0] + 1

  # Constraint on summation of T(i, j) == H[j].
  for j in range(1, V+1):      
    opt_model += plp.lpSum([T[i, j] for i in range(V+1)]) == H[j]

  # Constraint on T[i, j] == 0, edge (i, j) is not present in G.
  for i in range(V+1):
    for j in range(V+1):
      if (G[i, j] != 1):
          opt_model += T[i, j] == 0

  # Constraint on NT to be -INF or 1 depending on T[i, j] = 0 Or 1 respectively. 
  for i in range(V+1):
    for j in range(V+1):
      opt_model += NT[i, j] == (T[i, j] - 1)*V*10 + 1

  # Constraint on PT to be +INF or 1 depending on T[i, j] = 0 Or 1 respectively.
  for i in range(V+1):
    for j in range(V+1):
      opt_model += PT[i, j] == (-1)*(T[i, j] - 1)*V*10 + 1

  # Constraint on T[c, v] >= 1, i.e., atleast one edge there must be from the cloud.
  opt_model += plp.lpSum([T[0, i] for i in range(1, V+1)]) >= 1

  # Constraint on consecutive edges depth.
  for i in range(V+1):
    for j in range(V+1):
        if(G[i, j] == 1):
          opt_model += D[j] - D[i] - NT[i, j] >= 0 
          opt_model += D[j] - D[i] - PT[i, j] <= 0

  # Constraint on T[c, v] = 1, if D[v] = 1. Obvious.
  for i in range(1, V+1):
    opt_model += T[0, i] >= (-1)*D[i] + 2

  # Constraint for having H[i] = 1, if any 'j' is visited from 'i' such that T[i, j] = 1.
  for i in range(1, V+1):
    for j in range(1, V+1):
      opt_model += T[i, j] + T[i, j] <= H[i] + H[j]

  status = opt_model.solve()

  print(plp.LpStatus[status] + " Solution")
  print("Optimal Cost = " + str(plp.value(opt_model.objective)))

  print("")

  for i in range(V+1):
      for j in range(V+1):
          if (plp.value(T[i, j]) == 1):
              print(T[i, j] , plp.value(T[i, j]))

  print("")

  for i in range(V+1):
    print(D[i] , plp.value(D[i]))